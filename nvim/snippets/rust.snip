# functions

snippet     fn
abbr        fn () {}
options     head
    fn ${1:#:func_name}(${2:#:args}) {
        ${0:TARGET}
    }

snippet     fn-
abbr        fn () {}
options     head
    fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
        ${0:TARGET}
    }

snippet     pubfn
abbr        pubfn () {}
options     head
    pub fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
        ${0:TARGET}
    }

snippet     test
alias   testfn
options     head
    #[test]
    fn ${1:#:test_function_name}() {
        ${0:TARGET}
    }

snippet testmod "Test module"
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}

snippet     pubnew
abbr        pub fn new() {}
options     head
    pub fn new(${1}) -> ${2:#:Name} {
        ${0:TARGET}
    }

snippet     impl
options     head
    impl ${1} {
        ${0:TARGET}
    }

snippet     implfor
options     head
    impl ${1} for ${2} {
        ${0:TARGET}
    }

snippet     trait
options     head
    trait ${1} {
        ${0:TARGET}
    }

# macros

snippet     macro
    ${1:#:macro_name}!(${2})${3}

snippet     bfl
abbr        bitflags!
    bitflags! {
        ${0:TARGET}
    }

snippet     pln
alias p
abbr        println!
    println!(${1:"\{\}"}, ${0:TARGET});

snippet     epln plne
alias p pe printerr
abbr        eprintln!
    eprintln!(${1:"\{\}"}, ${0:TARGET});

snippet     fm
abbr        format!
    format!("${1:\{\}}", ${0:TARGET});

# attributes

snippet     ec
abbr        extern crate
options     head
    extern crate ${0:TARGET};

snippet     ecl
abbr        extern crate log
options     head
    #![feature(phase)]
    #[phase(plugin, link)] extern crate log;

snippet     crate
options     head
    #![crate_name=${1:#:crate_name}]

snippet     derive
alias       der
options     head
    #[derive(${1:TARGET})]${2}

snippet feat "feature attribute"
	#![feature(${1:plugin})]

# statements

snippet     mod
options     head
    mod ${1:#:mod_name} {
        ${0:TARGET}
    }

snippet     let
    let ${1:TARGET} = ${2};${3}

snippet     if
abbr        if {}
    if ${1:#:condition} {
        ${0:TARGET}
    }

snippet else
    else {
        ${0:TARGET}
    }

snippet elseif
    } else if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     ifelse
abbr        if () {} else {}
    if ${1:#:condition} {
        ${2:TARGET}
    } else {
        ${3}
    }

snippet     forin
abbr        forin  {}
    for ${1} in ${2} {
        $0
    }

snippet     match
    match ${1:TARGET} {
        ${2:#:pattern} => ${3:#expr},${4}
    }

snippet     mcase
alias       case
    ${1:TARGET} => ${2:#expr},${3}

# data

snippet     struct
options     head
    struct ${1} {
        ${0:TARGET}
    }

snippet     pubstruct
abbr        pub struct
options     head
    pub struct ${1} {
        ${0:TARGET}
    }

snippet     enum
options     head
    enum ${1} {
        ${0:TARGET}
    }

snippet     penum
alias       pubenum
options     head
    pub enum ${1} {
        ${0:TARGET}
    }

snippet     opt
abbr        Option<A>
    Option<${1:()}>${2}

snippet     res
abbr        Result<A, B>
    Result<${1:#:~str}, ${2:#:()}>${3}

snippet useclap
options head
    extern crate clap;
    use clap::{Arg, App, SubCommand};

snippet clap
alias argparse
    let matches = App::new("${1:Name}")
                          .version("0.1")
                          .author("Maarten van Gompel (proycon) <proycon@anaproy.nl>")
                          .about("${2:Description})
                          //snippet hints --> addargb,addargs,addargi,addargf,addargpos
                          .get_matches();

    //hints: matches.is_present() , matches.value_of()

snippet addargb
                          .arg(Arg::with_name("${1:name}")
                            .long("${2:long}")
                            .short("${3:s}")
                            .help("${4:description}")
                            .required(${5:false}))


snippet addargs
alias addarg addargi addargf
                          .arg(Arg::with_name("${1:name}")
                            .long("${2:long}")
                            .short("${3:s}")
                            .help("${4:description}")
                            .takes_value(true)
                            .value_name(${5:STRING}")
                            .required(${6:false}))

snippet addargpos
                          .arg(Arg::with_name("${1:name}")
                            .help("${2:description}")
                            .takes_value(true)
                            .index(${3:1})
                            .required(${4:true}))


snippet header
options head
    /*
	 * ${1:Title}
	 *	by Maarten van Gompel (proycon)
	 *	proycon AT anaproy DOT nl
	 *
	 * ${2:Description}
     *
	 * Licensed under the GNU General Public License v3
	 *
     */

snippet useall "Some common uses"
options head
options head
    use std::fs::File;
    use std::io::Read;
    use std::fs;
    use std::error::Error;
    use std::fmt;
    use std::io;
    use std::iter::Iterator;
    use std::collections::HashMap;
    use std::time::{SystemTime, UNIX_EPOCH};
    use std::path::{Path,PathBuf};
    use std::iter::FromIterator;
    use std::str::{FromStr};


snippet usefile
options head
    use std::fs::File;
    use std::io::{Write,Read,BufReader,BufRead,Error};

snippet usefmt
options head
    use std::fmt;

snippet usehashmap
alias usehash usehm
options head
    use std::collections::{HashMap,HashSet};

snippet usetime
alias usedate usedatetime
options head
    use std::time::{SystemTime, UNIX_EPOCH};

snippet useiter
options head
    use std::iter::{Iterator,FromIterator};

snippet usepath
alias usepathbuf
options head


snippet display
alias impldisplay
options head
    impl fmt::Display for ${1:MyStruct} {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f,"{}",self.data)
            $0
        }
    }

snippet default "Default trait implementation"
alias impldefault
options head
    impl Default for ${1:MyStruct} {
        fn default() -> $1 {
            $1 {
                $0
            }
        }
    }

snippet fromstr "FromStr trait implementation"
alias implfromstr
options head
    impl FromStr for ${1:MyStruct} {
        fn from_str(s: &str) -> Result<$1,Err> {
            $0
        }
    }

snippet drop "Drop trait implementation (destructor)"
alias impldrop
options head
	impl Drop for ${1:Name} {
		fn drop(&mut self) {
			${0}
		}
	}

snippet asref "AsRef trait implementation"
alias implasref
options head
	impl AsRef<${1:Ref}> for ${2:Type} {
		fn as_ref(&self) -> &${3:$1} {
			&self.${0:field}
		}
	}

snippet asmut "AsMut trait implementation"
alias implasmut
options head
	impl AsMut<${1:Ref}> for ${2:Type} {
		fn as_mut(&mut self) -> &mut ${3:$1} {
			&mut self.${0:field}
		}
	}


snippet useregex
options head
    extern crate regex;
    use regex::Regex;

snippet useserde
options head
    extern crate serde;
    extern crate serde_json;
    #[macro_use]
    extern crate serde_derive;

snippet usereqwest
alias userequest
options head
    extern crate reqwest;

snippet userand
alias userng
options head
    extern crate rand;

    use rand::Rng;

snippet serdedef
alias serdedefault
options head
    #[serde(default)]

snippet serdederive
alias serdeder serdedev
options head
    #[derive(Serialize, Deserialize)]

snippet serdestruct
options head
    #[derive(Serialize, Deserialize)]
    struct ${1:MyStruct} {
        #[serde(default)]
        ${2:myfield}: ${3:String},
    }

snippet readjson
alias loadjson serdeloadjson serdereadjson
options head
    let ${1:data} = fs::read_to_string(${2:filename})?;
    let $1: ${3:serde_json::Value} = serde_json::from_str($1.as_str()).expect("Invalid JSON");

snippet writejson
alias savejson dumpjson serdewritejson
options head
    fs::write(${1:filename}, serde_json::to_string(self).expect("Unable to serialise JSON"));

snippet timestamp
alias unixtime
    std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).expect("Unable to get time").as_secs()

snippet mkdir
options head
    fs::create_dir_all(${1:&dir}).expect("Unable to create directory");

snippet exit
options head
    std::process::exit(${1:1});

snippet rand
alias randnum randint
    let mut rng = rand::thread_rng();
    let ${1:randnum}: ${2:u32} = rng.gen_range(${3:0}, ${4:max}); //or use rng.gen() for full range

snippet regex
alias findregex findallregex
options head
    for candidate in Regex::new(${1:regex}).unwrap().find_iter(${2:reference}) {
        let candidate = candidate.as_str().to_lowercase();
        $0
    }

snippet stdin
alias prompt readline
options head
    print!(">>> ");
    std::io::stdout().flush().unwrap();
    let stdin = std::io::stdin();
    let input = stdin.lock().lines().next().unwrap().unwrap(); //read one line only

snippet pathbuf
alias pb pbf
    PathBuf::from(${1:filename})

snippet fileexists
alias fex
    PathBuf::from(${1:filename}).exists()

snippet pathjoin
alias pj
    PathBuf::from(${1:base}).join(${2:part})

snippet spawn "spawn a thread"
alias thread
	thread::spawn(${1:move }|| {
		${0}
	});


snippet box "Box::new()"
	Box::new(${0:${VISUAL}})
snippet rc "Rc::new()"
	Rc::new(${0:${VISUAL}})
snippet arc "Arc::new()"
	Arc::new(${0:${VISUAL}})
snippet unim "unimplemented!()"
	unimplemented!()

snippet httpget
alias requestget reqwestget
options head
    let mut res = reqwest::get(${1:url})?;
    let mut body = String::new();
    res.read_to_string(&mut body)?;
    //hints: res.status(), res.headers()

snippet usewalkdir
alias usewalk
options head
    extern crate walkdir;
    use walkdir::Walkdir;

snippet walk
alias walkdir
options head
    for entry in WalkDir::new(".")
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok()) {
        let filename = entry.file_name().to_string_lossy();
        //let sec = entry.metadata()?.modified()?; //get some metadata,

        if filename.ends_with(".json") { // && sec.elapsed()?.as_secs() < 86400 {
            println!("{}", filename);
        }
    }

snippet useglob
options head
    extern crate glob;
    use glob::{glob_with, MatchOptions};

snippet glob
options head
    let options = MatchOptions {
        case_sensitive: false,
        ..Default::default()
    };

    for entry in glob_with(${1:pattern}, &options)? {
        println!("{}", entry?.display());
    }

snippet writefile
alias openwrite
options head
    let mut ${1:f} = File::create(${2:filename})?;
    write!($1, ${3:data})?;

snippet readfile
alias openread
options head
    let ${1:f} = File::open(${2:filename})?;
    let $1_buffer = BufReader::new($1);
    for line in $1_buffer.lines() {
        println!("{}", line?);
    }

snippet usecommand
options head
    use std::process::Command;

snippet command
alias system exec
options head
    let output = Command::new(${1:tool}).arg(${2:arg}).output()?;
    if output.status.success () {
        //hints: handle output.stdout , output.stderr, etc
    }

snippet usendarray
alias usenda
options head
    extern crate ndarray;

snippet usenalgebra
alias usenalg
options head
    extern crate nalgebra;

snippet ndarray
    Array::from(${1:vec});

snippet useunicode
options head
    #[macro_use]
    extern crate unicode_segmentation;
    use unicode_segmentation::UnicodeSegmentation;

snippet splitstring
alias graphemes
    UnicodeSegmentation::graphemes(${1:s}, true).collect::<Vec<&str>>()



