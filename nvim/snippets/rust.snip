# functions

snippet     fn
abbr        fn () {}
options     head
    fn ${1:#:func_name}(${2:#:args}) {
        ${0:TARGET}
    }

snippet     fn-
abbr        fn () {}
options     head
    fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
        ${0:TARGET}
    }

snippet     pubfn
abbr        pubfn () {}
options     head
    pub fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {
        ${0:TARGET}
    }

snippet     test
options     head
    #[test]
    fn ${1:#:test_function_name}() {
        ${0:TARGET}
    }

snippet     pubnew
abbr        pub fn new() {}
options     head
    pub fn new(${1}) -> ${2:#:Name} {
        ${0:TARGET}
    }

snippet     impl
options     head
    impl ${1} {
        ${0:TARGET}
    }

snippet     implfor
options     head
    impl ${1} for ${2} {
        ${0:TARGET}
    }

snippet     trait
options     head
    trait ${1} {
        ${0:TARGET}
    }

# macros

snippet     macro
    ${1:#:macro_name}!(${2})${3}

snippet     bfl
abbr        bitflags!
    bitflags! {
        ${0:TARGET}
    }

snippet     pln
alias p
abbr        println!
    println!(${1:"\{\}"}, ${0:TARGET});

snippet     fm
abbr        format!
    format!("${1:\{\}}", ${0:TARGET});

# attributes

snippet     ec
abbr        extern crate
options     head
    extern crate ${0:TARGET};

snippet     ecl
abbr        extern crate log
options     head
    #![feature(phase)]
    #[phase(plugin, link)] extern crate log;

snippet     crate
options     head
    #![crate_name=${1:#:crate_name}]

snippet     derive
options     head
    #[derive(${1:TARGET})]${2}

# statements

snippet     mod
options     head
    mod ${1:#:mod_name} {
        ${0:TARGET}
    }

snippet     let
    let ${1:TARGET} = ${2};${3}

snippet     if
abbr        if {}
    if ${1:#:condition} {
        ${0:TARGET}
    }

snippet else
    else {
        ${0:TARGET}
    }

snippet elseif
    } else if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     ifelse
abbr        if () {} else {}
    if ${1:#:condition} {
        ${2:TARGET}
    } else {
        ${3}
    }

snippet     forin
abbr        forin  {}
    for ${1} in ${2} {
        ${0:TARGET}
    }

snippet     match
    match ${1:TARGET} {
        ${2:#:pattern} => ${3:#expr},${4}
    }

snippet     mcase
alias       case
    ${1:TARGET} => ${2:#expr},${3}

# data

snippet     struct
options     head
    struct ${1} {
        ${0:TARGET}
    }

snippet     pubstruct
abbr        pub struct
options     head
    pub struct ${1} {
        ${0:TARGET}
    }

snippet     enum
options     head
    enum ${1} {
        ${0:TARGET}
    }

snippet     opt
abbr        Option<A>
    Option<${1:()}>${2}

snippet     res
abbr        Result<A, B>
    Result<${1:#:~str}, ${2:#:()}>${3}

snippet useclap
options head
    extern crate clap;
    use clap::{Arg, App, SubCommand};

snippet clap
alias argparse
    let matches = App::new("${1:Name}")
                          .version("0.1")
                          .author("Maarten van Gompel (proycon) <proycon@anaproy.nl>")
                          .about("${2:Description})
                          //snippet hints --> addargb,addargs,addargi,addargf,addargpos
                          .get_matches()

snippet addargb
                          .arg(Arg::with_name("${1:name}")
                            .long("${2:long}"})
                            .short("${3:s}"})
                            .help("${4:description}"})
                            .required(${5:false}))


snippet addargs
alias addarg addargi addargf
                          .arg(Arg::with_name("${1:name}")
                            .long("${2:long}"})
                            .short("${3:s}"})
                            .help("${4:description}"})
                            .takes_value(true)
                            .value_name(${5:STRING}")
                            .required(${6:false}))

snippet addargpos
                          .arg(Arg::with_name("${1:name}")
                            .help("${2:description}"})
                            .takes_value(true)
                            .index(${3:1})
                            .required(${4:true}))


snippet header
options head
    /*
	 * ${1:Title}
	 *	by Maarten van Gompel (proycon)
	 *	proycon AT anaproy DOT nl
	 *
	 * ${2:Description}
     *
	 * Licensed under the GNU General Public License v3
	 *
     */

snippet useall "Some common uses"
options head
    use std::fs::File;
    use std::io::Read;
    use std::fs;
    use std::error::Error;
    use std::fmt;
    use std::io;
    use std::iter::Iterator;
    use std::collections::HashMap;
    use std::time::{SystemTime, UNIX_EPOCH};
    use std::path::{Path,PathBuf};
    use std::iter::FromIterator;

snippet display
options head
    impl fmt::Display for ${1:MyStruct} {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f,"{}",self.data)
        }
    }

snippet useserde
options head
    extern crate serde;
    extern crate serde_json;
    #[macro_use]
    extern crate serde_derive;

snippet serdedef
alias serdedefault
options head
    #[serde(default)]

snippet serdederive
alias serdeder serdedev
options head
    #[derive(Serialize, Deserialize)]

snippet serdestruct
options head
    #[derive(Serialize, Deserialize)]
    struct ${1:MyStruct} {
        #[serde(default)]
        ${2:myfield}: ${3:String},
    }

snippet readjson
alias loadjson serdeloadjson serdereadjson
    let ${1:data} = fs::read_to_string(${2:filename})?;
    let $1: ${3:serde_json::Value} = serde_json::from_str($1.as_str()).expect("Invalid JSON");

snippet writejson
alias savejson dumpjson serdewritejson
    fs::write(${1:filename}, serde_json::to_string(self).expect("Unable to serialise JSON"));

